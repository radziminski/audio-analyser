import { BBox, Vector, VectorType, CurveOptions } from './interfaces';
export interface CurveInterpolatorOptions extends CurveOptions {
    arcDivisions?: number;
    lmargin?: number;
}
/**
 * Cubic curve interpolator
 */
export default class CurveInterpolator {
    _lmargin: number;
    _points: Vector[];
    _tension: number;
    _arcDivisions: number;
    _closed: boolean;
    _cache: {
        arcLengths?: number[];
        bbox?: BBox;
    };
    /**
     * Create a new interpolator instance
     * @param points control points
     * @param options curve interpolator options
     */
    constructor(points: Vector[], options?: CurveInterpolatorOptions);
    /**
     * Returns the time on curve at a position, given as a value between 0 and 1
     * @param position position on curve
     */
    getT(position: number): number;
    /**
     * Interpolate a point at the given position.
     * @param position position on curve (0 - 1)
     * @param target optional target
     */
    getPointAt<T extends VectorType>(position: number, target: T): T;
    getPointAt(position: number): Vector;
    /**
     * Get the tangent at the given position.
     * @param position position on curve (0 - 1)
     * @param target optional target
     */
    getTangentAt<T extends VectorType>(position: number, target: T): T;
    getTangentAt(position: number): Vector;
    /**
     * Get a bounding box for the curve or the segment given by the
     * from and to parameters
     * @param from position from
     * @param to position to
     */
    getBoundingBox(from?: number, to?: number): BBox;
    /**
     * Get uniformaly sampled points along the curve. Returns samples + 1 points.
     * @param samples number of samples (segments)
     * @param returnType optional return type
     * @param from start at position
     * @param to end at position
     */
    getPoints<T extends VectorType>(samples: number, returnType: {
        new (): T;
    }): T[];
    getPoints<T extends VectorType>(samples: number, returnType: {
        new (): T;
    }, from: number): T[];
    getPoints<T extends VectorType>(samples: number, returnType: {
        new (): T;
    }, from: number, to: number): T[];
    getPoints(): any;
    getPoints(samples: number): any;
    getPoints(samples: number, returnType: null, from: number, to: number): Vector[];
    /**
     * Find point(s) on the curve intersected by the given value along a given axis
     * @param v lookup value
     * @param axis index of axis [0=x, 1=y, 2=z ...]
     * @param max max solutions (i.e. 0=all, 1=first along curve, -1=last along curve)
     */
    lookup(v: number, axis?: number, max?: number, margin?: number): Vector[] | Vector;
    /**
     * Find positions (0-1) on the curve intersected by the given value along a given axis
     * @param v lookup value
     * @param axis index of axis [0=x, 1=y, 2=z ...]
     * @param max max solutions (i.e. 0=all, 1=first along curve, -1=last along curve)
     */
    lookupPositions(v: number, axis?: number, max?: number, margin?: number): number[];
    /**
     * Invalidates/clears cache
     */
    invalidateCache(): this;
    get points(): Vector[];
    get tension(): number;
    get closed(): boolean;
    get arcDivisions(): number;
    get arcLengths(): any[];
    get length(): any;
    get minX(): number;
    get maxX(): number;
    get minY(): number;
    get maxY(): number;
    get minZ(): number;
    get maxZ(): number;
    set points(pts: Vector[]);
    set tension(t: number);
    set arcDivisions(n: number);
    set closed(isClosed: boolean);
}
